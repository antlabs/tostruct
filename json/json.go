// antlabs, guonaihong 2023
// apache 2.0
package json

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"sort"
	"strings"

	"github.com/antlabs/gstl/mapex"
	"github.com/antlabs/tostruct/internal/name"
	"github.com/antlabs/tostruct/internal/tab"
	"github.com/antlabs/tostruct/option"
)

type JSON struct {
	option.Option
	obj       interface{}              // json/yaml 解成map[string]interface{} 或者[]interface{}
	Indent    int                      // 控制输出缩进
	buf       bytes.Buffer             // 存放内联结构体的数据
	structBuf map[string]*bytes.Buffer // 记录拆分结构体
}

// 原始json
/*
{
   "first" : ["a", "b"],
   "second" : {"b1" : "b1", "b2" : "b2"},
   "third" : [{"b1" : "b1", "b2" : "b2"}]
}
*/

// 生成拆开的结构体
/*
type AutoGenerated struct {
	First  []string `json:"first"`
	Second Second   `json:"second"`
	Third  []Third  `json:"third"`
}
type Second struct {
	B1 string `json:"b1"`
	B2 string `json:"b2"`
}
type Third struct {
	B1 string `json:"b1"`
	B2 string `json:"b2"`
}
*/

// 生成内联结构体
/*
	type AutoGenerated struct {
		First  []string `json:"first"`
		Second struct {
			B1 string `json:"b1"`
			B2 string `json:"b2"`
		} `json:"second"`
		Third []struct {
			B1 string `json:"b1"`
			B2 string `json:"b2"`
		} `json:"third"`
	}
*/

const (
	startStruct      = "type %s struct {\n"
	startArrayStruct = "type %s []struct {\n"
	endStruct        = "}"
	startArrayStart  = "%s []"
	startInlineMap   = "%s %sstruct {\n"       // 内联结构体开始
	endInlineMap     = "} `json:\"%s\"`"       // 内联结构体结束
	startMap         = "%s %s%s `json:\"%s\"`" // 拆开结构体开始
	endMap           = "}"                     // 拆开结构体结束
	emptyMap         = "%s struct {" +
		"} `json:\"%s\"`" +
		"}"
	keyName       = "%s %s `json:\"%s\"`"
	defStructName = "AutoGenerated"
	nilFmt        = "%s interface{} `json:\"%s\"`"
	stringFmt     = "%s %sstring `json:\"%s\"`"
	boolFmt       = "%s %sbool `json:\"%s\"`"
	float64Fmt    = "%s %sfloat64 `json:\"%s\"`"
	intFmt        = "%s %sint `json:\"%s\"`"
)

func Marshal(bytes []byte, opt ...option.OptionFunc) (b []byte, err error) {
	f, err := new(bytes, opt...)
	if err != nil {
		return nil, err
	}

	return f.marshal()
}

func new(jsonBytes []byte, opt ...option.OptionFunc) (f *JSON, err error) {
	var o map[string]interface{}
	jsonBytes = bytes.TrimSpace(jsonBytes)

	if b := Valid(jsonBytes); !b {
		return nil, fmt.Errorf("tostruct.json:Not qualified json")
	}

	var a []interface{}

	rv := &JSON{structBuf: make(map[string]*bytes.Buffer),
		Option: option.Option{Tag: "json", StructName: defStructName, Inline: true}}

	for _, o := range opt {
		o(&rv.Option)
	}

	if jsonBytes[0] == '{' {
		rv.buf.WriteString(fmt.Sprintf(startStruct, rv.StructName))
		json.Unmarshal(jsonBytes, &o)
		rv.obj = o
	} else if jsonBytes[0] == '[' {
		rv.buf.WriteString(fmt.Sprintf(startArrayStruct, rv.StructName))
		json.Unmarshal(jsonBytes, &a)
		rv.obj = a
	}

	rv.Indent = 4
	return rv, nil
}

func (f *JSON) marshal() (b []byte, err error) {
	f.marshalValue("", f.obj, false, 0, &f.buf)
	f.buf.WriteString(endStruct)
	if !f.Inline {
		keys := mapex.Keys(f.structBuf)
		sort.Strings(keys)

		for i, v := range keys {
			if i == 0 {
				f.buf.WriteByte('\n')
			}
			f.buf.WriteString(f.structBuf[v].String())
		}
	}

	if b, err = format.Source(f.buf.Bytes()); err != nil {
		return nil, err
	}

	return b, nil
}

func (f *JSON) getStructTypeName(fieldName string) (structTypeName string, buf *bytes.Buffer) {

	structTypeName = fieldName
	for count := 0; ; count++ {

		if _, ok := f.structBuf[structTypeName]; ok {
			// 比较少见的情况， 结构体里面有重名变量
			// 使用fieldName + 数字编号的形式解决重名问题
			structTypeName = fmt.Sprintf("%s%d", fieldName, count)
			continue
		}
		buf = bytes.NewBuffer([]byte{})
		f.structBuf[structTypeName] = buf
		return
	}
}

func (f *JSON) marshalMap(key string, m map[string]interface{}, typePrefix string, depth int, buf *bytes.Buffer) {

	remaining := len(m)

	fieldName, tagName := name.GetFieldAndTagName(key)
	if remaining == 0 {
		buf.WriteString(fmt.Sprintf(emptyMap, fieldName, tagName))
		return
	}

	keys := make([]string, 0)
	for key := range m {
		keys = append(keys, key)
	}

	sort.Strings(keys)

	if len(key) > 0 {
		if f.Inline {
			buf.WriteString(fmt.Sprintf(startInlineMap, fieldName, typePrefix))
		} else {
			// 生成struct类型名和子结构体可以保存的子buf
			structTypeName, buf2 := f.getStructTypeName(fieldName)
			// 保存子结构体声明语句， type Third struct {
			buf2.WriteString(fmt.Sprintf("\n"+startStruct, structTypeName))
			// 在父结构体里，写入声明类型 Third  []Third  `json:"third"`
			buf.WriteString(fmt.Sprintf(startMap, fieldName, typePrefix, structTypeName, tagName))
			depth = 0
			buf = buf2
		}
	}

	for _, key := range keys {

		f.writeIndent(buf, depth+1)

		f.marshalValue(key, m[key], false, depth+1, buf)

		f.writeObjSep(buf)
	}

	f.writeIndent(buf, depth)
	if len(key) > 0 {
		if f.Inline {
			buf.WriteString(fmt.Sprintf(endInlineMap, tagName))
		} else {
			buf.WriteString(endStruct + "\n")

		}
	}
}

func (f *JSON) marshalArray(key string, a []interface{}, depth int, buf *bytes.Buffer) {
	if len(a) == 0 {
		buf.WriteString(fmt.Sprintf("%s interface{} `json:\"json:%s\"`", key, key))
		return
	}

	f.marshalValue(key, a[0], true, depth, buf)
}

func (f *JSON) marshalValue(key string, obj interface{}, fromArray bool, depth int, buf *bytes.Buffer) {
	typePrefix := ""
	if fromArray {
		typePrefix = "[]"
	}

	fieldName, tagName := name.GetFieldAndTagName(key)

	tmpFieldName := strings.ToUpper(fieldName)
	if tab.InitialismsTab[tmpFieldName] {
		fieldName = tmpFieldName
	}

	switch v := obj.(type) {
	case map[string]interface{}:
		f.marshalMap(key, v, typePrefix, depth, buf)
	case []interface{}:
		f.marshalArray(key, v, depth, buf)
	case string:
		buf.WriteString(fmt.Sprintf(stringFmt, fieldName, typePrefix, tagName))
	case float64:
		// int
		if float64(int(v)) == v {
			buf.WriteString(fmt.Sprintf(intFmt, fieldName, typePrefix, tagName))
			return
		}

		// float64
		buf.WriteString(fmt.Sprintf(float64Fmt, fieldName, typePrefix, tagName))
	case bool:
		buf.WriteString(fmt.Sprintf(boolFmt, fieldName, typePrefix, tagName))
	case nil:
		buf.WriteString(fmt.Sprintf(nilFmt, fieldName, tagName))
	}
}

func (f *JSON) writeIndent(buf *bytes.Buffer, depth int) {
	buf.WriteString(strings.Repeat(" ", f.Indent*depth))
}

func (f *JSON) writeObjSep(buf *bytes.Buffer) {
	if f.Indent != 0 {
		buf.WriteByte('\n')
	} else {
		buf.WriteByte(' ')
	}
}
